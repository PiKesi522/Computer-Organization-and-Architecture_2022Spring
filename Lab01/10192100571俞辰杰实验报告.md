<center>
    <h1>
        计算机组成与设计 Lab1
    </h1>
</center>
<center>
    <h4>
       	10192100571 俞辰杰
    </h4>
</center>



### 实验目的：

------

​		在此实验中，运用C++来模拟RISCV的指令级别的单周期循环，使用一些最简单的指令集（见下表）来模拟一些简单的RISCV的操作。在模拟运行的过程中，涉及到ALU的计算，PC地址的跳转，寄存器的读取，立即数的计算。

​		通过各个部分独立的实现，组合的运行，加深对于计算机底层设备的运行逻辑和设计方式

​		能够在用户层面加深对于RISCV指令集在机器层面上的操作和理解。		

​		通过编写机器码，能够理解对于RISCV指令集不同类型指令的组成形式和解释方法。

| **Name** | **Format Type** | **Opcode** (Binary) | **Func** **3(Binary)** | **Func** **7(Binary)** |
| -------- | --------------- | ------------------- | ---------------------- | ---------------------- |
| **add**  | R-Type          | 0110011             | 000                    | 0000000                |
| **sub**  | R-Type          | 0110011             | 000                    | 0100000                |
| **addi** | I-Type          | 0010011             | 000                    |                        |
| **and**  | R-Type          | 0110011             | 111                    | 0000000                |
| **or**   | R-Type          | 0110011             | 110                    | 0000000                |
| **xor**  | R-Type          | 0110011             | 100                    | 0000000                |
| **beq**  | SB-Type         | 1100011             | 000                    |                        |
| **jal**  | UJ-Type         | 1101111             |                        |                        |
| **ld**   | I-Type          | 0000011             | 011                    |                        |
| **sd**   | S-Type          | 0100011             | 011                    |                        |

<div STYLE="page-break-after: always;"></div>

### 实验步骤

------

- #### 	如果需要测试自己的代码需要自行更改imem.txt以及在代码中配置寄存器初始值以及数据内存存储值，代码内修改部分如下：

  - 寄存器堆RF初始化寄存器初始值

  ~~~C++
  RF(){
      Registers.resize(32);
      // 有32个寄存器
      Registers[0] = bitset<64>(0);
      // 0号寄存器一直为全零
      
  	/*================= 修改Register =================*/
      Registers[10] = bitset<64>("1");
      // x10 = 1
      Registers[13] = bitset<64>("110000");
      // x13 = &A[0] = 0x00000030
      Registers[14] = bitset<64>("10000");
      // x14 = &B[0] = 0x00000010
      Registers[28] = bitset<64>("11110");
      // x28 = i = 30
      Registers[29] = bitset<64>("1");
      // x29 = j = 1
      /*================= 修改Register =================*/
  }
  ~~~

  

  - 数据内存DMem初始化数据内存初始值

  ~~~C++
  DataMem(){
      DMem.resize(MemSize);
      ifstream dmem;
      string line;
      int i = 0;
      dmem.open("dmem.txt");
      if (dmem.is_open()){
          while (getline(dmem, line)){
              DMem[i] = bitset<8>(line.substr(0, 8));
              i++;
          }
          /*================= 修改DMem =================*/
          DMem[16 + 0 * 8 + 7] = bitset<8>("11111111");
          // DMem[16] = B[0] = 6
          DMem[16 + 1 * 8 + 6] = bitset<8>("1");
          DMem[16 + 1 * 8 + 7] = bitset<8>("00110111");
          // B[1] = 137
  
          DMem[48 + 0 * 8 + 7] = bitset<8>("0");
          // DMem[55] = A[0] = 0
          DMem[48 + 27 * 8 + 6] = bitset<8>("1");
          DMem[48 + 27 * 8 + 7] = bitset<8>("00110111");
          // A[27] = 137
          DMem[48 + 28 * 8 + 7] = bitset<8>("11100");
          // A[28] = 28
          DMem[48 + 29 * 8 + 7] = bitset<8>("11101");
          // A[29] = 29
          /*================= 修改DMem =================*/
      }
      else
          cout << "Unable to open file";
      dmem.close();
  }
  ~~~

  

- ####     如果不进行修改的话，可以直接运行RISC-V.cpp，运行代码如下CCM.txt所示：

​		样例程序的C语言代码（**不使用样例的测试代码，因为样例测试代码并不包含beq和jal指令**），RISCV汇编代码，以及对于的指令集的机器码存放于此

~~~C
/*============ 源测试C程序 ============*/
while(B[1] != A[i - j]){
    j += 1;
}
A[j] = B[0];

/*========== 简化得到以下C程序 ==========*/
while(true){
    if(B[1] == A[i - j]){
        break;
    }else{
        j += 1;
    }
}
A[j] = B[0]; 
~~~

​		此外，寄存器初始化和数据内存在代码中进行设定

~~~compile
x10 : 1
x12 : addr_temp
x13 : A[]
x14 : B[]
x27 : data_temp2
x28 : i（i = 30）
x29 : j（j = 1）
x30 : data_temp
~~~

<div STYLE="page-break-after: always;"></div>

​	**对应的riscv指令及32位指令码**

~~~compile
Loop:   sub x30, x28, x29 						// compute i-j 
00      0100000 11101 11100 000 11110 0110011
        add x12, x30, x30						// multiply by 8 
04      0000000 11110 11110 000 01100 0110011
        add x12, x12, x12 
08      0000000 01100 01100 000 01100 0110011
        add x12, x12, x12		
12      0000000 01100 01100 000 01100 0110011
        add x12, x12, x13       	
16      0000000 01101 01100 000 01100 0110011
        ld x30, 0(x12) 							// x30 load A[i-j] 
20      000000000000  01100 011 11110 0000011
        ld x27, 8(x14)      					// x31 load B[1]
24      000000001000  01110 011 11011 0000011
        beq x27, x30, Exit		(40 - 28 = 12 = 000000000110[0])
28      0 000000 11110 11011 000 0110 0 1100111
        add x29, x29, x10   					// j += 1
32      0000000 01010 11101 000 11101 0110011
        jal x0, Loop			(0 - 36 = -36 = 11111111111111101110[0])
36      1 1111101110 1 11111111 00000 1101111
Exit:   ld x30, 0(x14)         	 				// x30 = B[0]
40      000000000000  01110 011 11110 0000011
        add x12, x29, x29       				// j * 8
44      0000000 11101 11101 000 01100 0110011
        add x12, x12, x12
48      0000000 01100 01100 000 01100 0110011
        add x12, x12, x12
52      0000000 01100 01100 000 01100 0110011
        add x12, x12, x13
56      0000000 01101 01100 000 01100 0110011
        sd x30, 0(x12)         	 				// A[j] = x30
60      0000000 11110 01100 011 00000 0100011
        end
64      1111111 11111 11111 111 11111 1111111
~~~

~~~bina
01000001110111100000111100110011
00000001111011110000011000110011
00000000110001100000011000110011
00000000110001100000011000110011
00000000110101100000011000110011
00000000000001100011111100000011
00000000100001110011110110000011
00000001111011011000011001100111
00000000101011101000111010110011
11111101110111111111000001101111
00000000000001110011111100000011
00000001110111101000011000110011
00000000110001100000011000110011
00000000110001100000011000110011
00000000110101100000011000110011
00000001111001100011000000100011
11111111111111111111111111111111
~~~

<div STYLE="page-break-after: always;"></div>

### 实验结果

------

#### 	**对于给定的测试例子，在RFresult.txt中，可以看到寄存器的最终结果：**

~~~txt
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000001 x10 = 1
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000001001000 x12 = &A[3]
0000000000000000000000000000000000000000000000000000000000110000 x13 = &A[0] 
0000000000000000000000000000000000000000000000000000000000010000 x14 = &B[0]
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000100110111 x27 = B[1]
0000000000000000000000000000000000000000000000000000000000011110 x28 = i
0000000000000000000000000000000000000000000000000000000000000011 x29 = j
0000000000000000000000000000000000000000000000000000000011111111 x30 = A[j]
0000000000000000000000000000000000000000000000000000000000000000
~~~

<div STYLE="page-break-after: always;"></div>

#### 	**在dmemresult.txt中，可以跟踪数据内存的数据：**

​		按照预期 $A[j]$ 和 $B[0]$ 应该有相同的数据，$A[i-j] = A[27]$ 和 $B[1]$应该有相同的结果

​		根据上方寄存器的结果，我们反向追踪数据内存的位置，其中：

- $A[j]$ 应该在 **0x1001000  + 0x111= 79** 的内存位置

- $B[0]$ 应该在 **0x10000 + 0x111 = 23** 的内存位置 

  ​							<img src="C:\Users\86008\AppData\Roaming\Typora\typora-user-images\image-20220408221841015.png" alt="image-20220408221841015" style="zoom: 80%;" />		<img src="C:\Users\86008\AppData\Roaming\Typora\typora-user-images\image-20220408221815621.png" alt="image-20220408221815621" style="zoom: 80%;" />

  ##### 													**$ A[j]$ 和 $B[0]$ 有相同的结果**





- $A[27]$ 应该在 **0x110000 + 0x11011000 + 0x111 = 0x100001111 = 271** 的内存位置

- $B[1]$ 应该在 **0x11000 + 0x111 =  0x11111 = 31** 的内存位置

  ​							<img src="C:\Users\86008\AppData\Roaming\Typora\typora-user-images\image-20220408221138711.png" alt="image-20220408221138711" style="zoom: 80%;" /> 	<img src="C:\Users\86008\AppData\Roaming\Typora\typora-user-images\image-20220408221224111.png" alt="image-20220408221224111" style="zoom: 80%;" />

  ##### 													**$A[27]$ 和 $B[1]$ 有相同的结果**

  <div STYLE="page-break-after: always;"></div>

------

​		在实验过程中，我们跟踪输出了每条指令所**读取的寄存器内容、立即数数字，执行的操作类型，PC的目标地址，读写操作的目标地址**。

​		由于执行条数过多，故不全部展示，如果修改代码，可以通过此方法在运行过程中及时观察运行过程是否符合逻辑，下图各种类型操作分别展示一次。

<img src="C:\Users\86008\AppData\Roaming\Typora\typora-user-images\image-20220408213808456.png" alt="image-20220408213808456" style="zoom:74%;" />

<center>
    <b>图1 数据计算R-type指令结果</b>
</center>



<img src="C:\Users\86008\AppData\Roaming\Typora\typora-user-images\image-20220408213153946.png" alt="image-20220408213153946" style="zoom: 75%;" />

<center>
    <b>图2 数据内存读写sd/ld指令结果</b>
</center>



<img src="C:\Users\86008\AppData\Roaming\Typora\typora-user-images\image-20220408213121234.png" alt="image-20220408213121234" style="zoom:80%;" />

<center>
    <b>图3 分支跳转beq指令结果</b>
</center>



<img src="C:\Users\86008\AppData\Roaming\Typora\typora-user-images\image-20220408213255634.png" alt="image-20220408213255634" style="zoom:77%;" />

<center>
    <b>图4 直接跳转jal指令结果</b>
</center>

